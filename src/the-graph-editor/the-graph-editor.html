<!-- NOTICE: include 'the-graph-elem'' used in template -->
<link rel="import" href="../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../the-graph/the-graph-elem.html">

<dom-module id="the-graph-editor" attributes="grid snap width height autolayout theme selectedNodes errorNodes selectedEdges animatedEdges onContextMenu displaySelectionGroup forceSelection"
  touch-action="none">
  <template>
    <h1>Graph Editor</h1>
    <the-graph-elem id="graph" name="{{ graph.properties.name }}" graph="{{fbpGraph}}" menus="{{menus}}" width="{{width}}" height="{{height}}"
      pan="{{pan}}" scale="{{scale}}" autolayout="{{autolayout}}" theme="{{theme}}" selectedNodes="{{selectedNodes}}" errorNodes="{{errorNodes}}"
      selectedEdges="{{selectedEdges}}" animatedEdges="{{animatedEdges}}" displaySelectionGroup="{{displaySelectionGroup}}"
      forceSelection="{{forceSelection}}" getMenuDef="{{getMenuDef}}">
    </the-graph-elem>
  </template>
  <script>
    class TheGraphEditor extends Polymer.Element {
      static get is() {
        return 'the-graph-editor'
      }

      // NOTE: properties passed in from network example
      // width="800"
      // height="600"
      // grid="72"
      static get properties() {
        return {
          // property ??
          graph: {
            type: Object,
            value: null,
            observer: '_graphChanged'
          },
          grid: {
            type: Number,
            value: 72
          },
          snap: {
            type: Number,
            value: 36
          },
          width: {
            type: Number,
            value: 800,
            observer: '_widthChanged'
          },
          height: {
            type: Number,
            value: 600,
            observer: '_heightChanged'
          },
          scale: {
            Number,
            value: 1
          },
          // property ??
          fbpGraph: {
            type: Object,
            value: null,
          },
          // property ??
          menus: {
            type: Object,
            value: null,
          },
          autolayout: {
            type: Boolean,
            value: false
          },
          theme: {
            type: String,
            value: "dark"
          },
          displaySelectionGroup: {
            type: Boolean,
            value: true
          },
          forceSelection: {
            type: Boolean,
            value: false
          }
        }
      }

      constructor() {
        super()
        this.log('create')
        this.plugins = {}
        this.selectedNodes = []
        this.copyNodes = []
        this.errorNodes = {}
        this.selectedEdges = []
        this.animatedEdges = []

        this.pan = [0, 0];

        //
        this.menus = TheGraph.editor.getDefaultMenus(this);
      }

      // static get observers() {
      //   return [
      //     /* observer array just like 1.x */
      //     '_myPropChanged(myProp.*)'
      //   ]
      // }

      log(...args) {
        console.log('the-graph-EDITOR', ...args)
      }

      ready() {
        super.ready()
        this.log('ready')
      }

      connectedCallback() {
        super.connectedCallback();
        this.log('connected')
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.log('disconnected')
        for (var name in this.plugins) {
          this.plugins[name].unregister(this);
          delete this.plugins[name];
        }
      }
      addPlugin(name, plugin) {
        this.log('addPlugin')
        this.plugins[name] = plugin;
        plugin.register(this);
      }
      addMenu(type, options) {
        this.log('addMenu')
        // options: icon, label
        this.menus[type] = options;
      }
      addMenuCallback(type, callback) {
        this.log('addMenuCallback')
        if (!this.menus[type]) {
          return;
        }
        this.menus[type].callback = callback;
      }
      addMenuAction(type, direction, options) {
        this.log('addMenuAction')
        if (!this.menus[type]) {
          this.menus[type] = {};
        }
        var menu = this.menus[type];
        menu[direction] = options;
      }
      getMenuDef(options) {
        this.log('getMenuDef')
        // Options: type, graph, itemKey, item
        if (options.type && this.menus[options.type]) {
          var defaultMenu = this.menus[options.type];
          if (defaultMenu.callback) {
            return defaultMenu.callback(defaultMenu, options);
          }
          return defaultMenu;
        }
        return null;
      }

      // attributeChanged (legacy)
      _widthChanged(width, oldWidth) {
        this.log('widthChanged', width, oldWidth)
        this.style.width = width + "px";
      }

      // attributeChanged (legacy)
      _heightChanged(height, oldHeight) {
        this.log('heightChanged', height, oldHeight)
        this.style.height = height + "px";
      }

      // attributeChanged (old, new)
      _graphChanged(graph, oldGraph) {
        this.log('graphChanged', graph, oldGraph)
        if (graph && typeof graph.addNode === 'function') {
          this.buildInitialLibrary(graph);
          this.fbpGraph = graph;
          return;
        }

        var fbpGraph;
        if ('fbpGraph' in window) {
          fbpGraph = window.fbpGraph;
        }
        if (!fbpGraph && 'require' in window) {
          fbpGraph = require('fbp-graph');
        }
        if (!fbpGraph) {
          console.warn(
            'Missing fbp-graph dependency! Should be built with Webpack/Browserify to require it, or accessible on window'
          );
          return;
        }

        if (!graph) {
          console.log('no graph to load in fbpGraph', graph)
          return
        }

        fbpGraph.graph.loadJSON(graph, function (err, graph) {
          console.log('graph loadJSON', graph)
          this.buildInitialLibrary(graph);
          this.fbpGraph = graph;
          console.log('dispatch graphInitialised')
          var event = new CustomEvent('graphInitialised', {
            bubbles: true
          })
          this.dispatchEvent(event);
        }.bind(this));
      }

      buildInitialLibrary(fbpGraph) {
        this.log('buildInitialLibrary', fbpGraph)
        // if (Object.keys(this.$.graph.library).length !== 0) {
        //   // We already have a library, skip
        //   console.log('We already have a library')
        //   // TODO what about loading a new graph? Are we making a new editor?
        //   return;
        // }
        var components = TheGraph.library.componentsFromGraph(fbpGraph);
        console.log('Graph Components', components)
        components.forEach(function (component) {
          this.registerComponent(component, true);
        }.bind(this));
      }

      registerComponent(definition, generated) {
        console.log('graph registerComponent', definition)
        this.$.graph.registerComponent(definition, generated);
      }

      libraryRefresh() {
        this.$.graph.debounceLibraryRefesh();
      }
      updateIcon(nodeId, icon) {
        this.$.graph.updateIcon(nodeId, icon);
      }
      rerender() {
        this.$.graph.rerender();
      }
      triggerAutolayout() {
        this.$.graph.triggerAutolayout();
      }
      triggerFit() {
        this.$.graph.triggerFit();
      }
      animateEdge(edge) {
        // Make sure unique
        var index = this.animatedEdges.indexOf(edge);
        if (index === -1) {
          this.animatedEdges.push(edge);
        }
      }
      unanimateEdge(edge) {
        var index = this.animatedEdges.indexOf(edge);
        if (index >= 0) {
          this.animatedEdges.splice(index, 1);
        }
      }
      addErrorNode(id) {
        this.errorNodes[id] = true;
        this.updateErrorNodes();
      }
      removeErrorNode(id) {
        this.errorNodes[id] = false;
        this.updateErrorNodes();
      }
      clearErrorNodes() {
        this.errorNodes = {};
        this.updateErrorNodes();
      }
      updateErrorNodes() {
        this.$.graph.errorNodesChanged();
      }
      focusNode(node) {
        this.$.graph.focusNode(node);
      }
      getComponent(name) {
        return this.$.graph.getComponent(name);
      }
      getLibrary() {
        return this.$.graph.library;
      }
      toJSON() {
        return this.fbpGraph.toJSON();
      }
    }
    window.customElements.define(TheGraphEditor.is, TheGraphEditor);
  </script>
</dom-module>