<dom-module id="the-graph-elem" attributes="graph menus library width height autolayout theme selectedNodes errorNodes selectedEdges animatedEdges getMenuDef pan scale maxZoom minZoom displaySelectionGroup forceSelection offsetY offsetX"
  touch-action="none">

  <template>
    <link rel="stylesheet" href="../themes/the-graph-dark.css">
    <link rel="stylesheet" href="../themes/the-graph-light.css">
    <div id="svgcontainer"></div>
  </template>

  <script>
    console.log('GestureEventListeners', Polymer.GestureEventListeners)

    class TheGraphElem extends Polymer.Element {
      static get is() {
        return 'the-graph-elem'
      }

      static get properties() {
        return {
          // this.graph = null;
          // this.library = null;
          // this.menus = null;
          // appView: null,
          // graphView: null,
          // autolayouter: null,
          graph: {
            type: Object,
            value: null,
            observer: '_graphChanged'
          },
          menus: {
            type: Object,
            value: null,
            observer: '_menusChanged'
          },
          library: {
            type: Object,
            value: null
          },
          width: {
            type: Number,
            value: 800,
            observer: '_widthChanged'
          },
          height: {
            type: Number,
            value: 600,
            observer: '_heightChanged'
          },
          scale: {
            type: Number,
            value: 1,
            // observer: '_scaleChanged'
          },
          minZoom: {
            type: Number,
            value: 0.15,
            // observer: '_minZoomChanged'
          },
          maxZoom: {
            type: Number,
            value: 15,
            // observer: '_maxZoomChanged'
          },
          editable: {
            type: Boolean,
            value: true,
            // observer: '_editableChanged'
          },
          autolayout: {
            type: Boolean,
            value: false,
            observer: '_autolayoutChanged'
          },
          grid: {
            type: Number,
            value: 72,
            // observer: '_gridChanged'
          },
          snap: {
            type: Number,
            value: 36,
            // observer: '_snapChanged'
          },
          theme: {
            type: String,
            value: 'dark',
            observer: '_themeChanged'
          },
          selectedNodes: {
            type: Array,
            value: [],
            observer: '_selectedNodesChanged'
          },
          selectedNodesHash: {
            type: Object,
            value: {},
            observer: '_selectedNodesHashChanged'
          },
          errorNodes: {
            type: Object,
            value: {},
            observer: '_errorNodesChanged'
          },
          selectedEdges: {
            type: Array,
            value: [],
            observer: '_selectedEdgesChanged'
          },
          animatedEdges: {
            type: Array,
            value: [],
            observer: '_animatedEdgesChanged'
          },
          displaySelectionGroup: {
            type: Boolean,
            value: true,
            observer: '_displaySelectionGroupChanged'

          },
          forceSelection: {
            type: Boolean,
            value: false,
            observer: '_forceSelectionChanged'
          },
          offsetY: {
            type: Number,
            value: null
          },
          offsetX: {
            type: Number,
            value: null
          }
        }
      }

      constructor() {
        super()
        this.log('create')

        this.debounceLibraryRefeshTimer = null;
        this.library = {};
        // Default pan
        this.pan = [0, 0];
        // Initializes the autolayouter

        // TODO: bower install dependency: klayjs-noflo
        // how to make it available globally!?
        // https://github.com/noflo/klayjs-noflo

        this.autolayouter = klayNoflo.init({
          onSuccess: this.applyAutolayout.bind(this),
          workerScript: "/src/klay.js"
        });
        this.log('created')
      }

      log(...args) {
        console.log('the-graph', ...args)
      }

      // ready() {
      //   super.ready()
      //   this.log('ready')
      //   // this._themeChanged();
      // }

      connectedCallback() {
        super.connectedCallback();
        this.log('connected')
        // this._themeChanged();
      }

      _themeChanged(theme, oldTheme) {
        this.log('themeChanged')
        // sets class of div#svgcontainer in template
        this.$.svgcontainer.className = "the-graph-" + theme;
      }

      _graphChanged(graph, oldGraph) {
        this.log('graphChanged', graph, oldGraph)
        if (oldGraph && oldGraph.removeListener) {
          oldGraph.removeListener("endTransaction", this.fireChanged);
        }
        // Listen for graph changes
        var _graph = this.graph
        this.log('add observers/listeners to _graph', _graph)

        if (_graph) {
          this.log('ADDING observers/listeners to graph', _graph)
          _graph.on("endTransaction", this.fireChanged.bind(this));

          // Listen for autolayout changes
          if (this.autolayout) {
            var triggerAutolayout = this.triggerAutolayout.bind(this)

            _graph.on('addNode', triggerAutolayout);
            _graph.on('removeNode', triggerAutolayout);
            _graph.on('addInport', triggerAutolayout);
            _graph.on('removeInport', triggerAutolayout);
            _graph.on('addOutport', triggerAutolayout);
            _graph.on('removeOutport', triggerAutolayout);
            _graph.on('addEdge', triggerAutolayout);
            _graph.on('removeEdge', triggerAutolayout);
          }
        } else {
          console.error('no graph to add observers/listeners to yet...')
        }

        if (this.appView) {
          // Remove previous instance
          ReactDOM.unmountComponentAtNode(this.$.svgcontainer);
        }

        // Setup app
        this.$.svgcontainer.innerHTML = "";

        var app = {
          svgcontainer: this.$.svgcontainer,
          graph: graph,
          width: this.width,
          minZoom: this.minZoom,
          maxZoom: this.maxZoom,
          height: this.height,
          library: this.library,
          menus: this.menus,
          editable: this.editable,
          onEdgeSelection: this.onEdgeSelection.bind(this),
          onNodeSelection: this.onNodeSelection.bind(this),
          onPanScale: this.onPanScale.bind(this),
          getMenuDef: this.getMenuDef,
          displaySelectionGroup: this.displaySelectionGroup,
          forceSelection: this.forceSelection,
          offsetY: this.offsetY,
          offsetX: this.offsetX
        }
        console.log('app', app)
        if (!graph) {
          // throw new Error('no graph to render in app')
          console.error('no graph to render in app')
          return
        }

        this.appView = ReactDOM.render(
          window.TheGraph.App(app),
          this.$.svgcontainer
        );
        this.graphView = this.appView.refs.graph;
      }

      onPanScale(x, y, scale) {
        this.pan[0] = x;
        this.pan[1] = y;
        this.scale = scale;
      }

      onEdgeSelection(itemKey, item, toggle) {
        if (itemKey === undefined) {
          if (this.selectedEdges.length > 0) {
            this.selectedEdges = [];
          }
          var edgesSelectedEvent = new CustomEvent('edges', {
            detail: this.selectedEdges,
            bubbles: true
          })
          this.dispatchEvent(edgesSelectedEvent);
          return;
        }
        if (toggle) {
          var index = this.selectedEdges.indexOf(item);
          var isSelected = (index !== -1);
          var shallowClone = this.selectedEdges.slice();
          if (isSelected) {
            shallowClone.splice(index, 1);
            this.selectedEdges = shallowClone;
          } else {
            shallowClone.push(item);
            this.selectedEdges = shallowClone;
          }
        } else {
          this.selectedEdges = [item];
        }
        this.fire('edges', this.selectedEdges);
      }

      onNodeSelection(itemKey, item, toggle) {
        if (itemKey === undefined) {
          this.selectedNodes = [];
        } else if (toggle) {
          var index = this.selectedNodes.indexOf(item);
          var isSelected = (index !== -1);
          if (isSelected) {
            this.selectedNodes.splice(index, 1);
          } else {
            this.selectedNodes.push(item);
          }
        } else {
          this.selectedNodes = [item];
        }
        var selectedNodesEvent = this._buildEvent('nodes', this.selectedNodes)
        // https://dom.spec.whatwg.org/#interface-customevent
        console.log('onNodeSelection - distach event: nodes', this.selectedNodes)
        this.dispatchEvent(selectedNodesEvent);
      }

      _buildEvent(name, detail) {
        return new CustomEvent(name, {
          bubbles: true,
          detail: detail
        })
      }

      _selectedNodesChanged() {
        console.log('selected nodes changed', this.selectedNodes)
        var selectedNodesHash = {};
        for (var i = 0, len = this.selectedNodes.length; i < len; i++) {
          selectedNodesHash[this.selectedNodes[i].id] = true;
        }
        this.selectedNodesHash = selectedNodesHash;


        // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
        // https://developer.mozilla.org/en-US/docs/Web/API/Event

        var selectedNodesEvent = this._buildEvent('nodes', this.selectedNodes)
        // https://dom.spec.whatwg.org/#interface-customevent
        console.log('onNodeSelection - distach event: nodes', this.selectedNodes)
        this.dispatchEvent(selectedNodesEvent);
      }

      _selectedNodesHashChanged() {
        if (!this.graphView) {
          return;
        }
        this.graphView.setSelectedNodes(this.selectedNodesHash);
      }

      _errorNodesChanged() {
        if (!this.graphView) {
          return;
        }
        this.graphView.setErrorNodes(this.errorNodes);
      }

      _selectedEdgesChanged() {
        if (!this.graphView) {
          return;
        }
        this.graphView.setSelectedEdges(this.selectedEdges);

        var selectedEdgesEvent = this._buildEvent('edges', this.selectedEdges)
        // https://dom.spec.whatwg.org/#interface-customevent
        console.log('selectedEdgesChanged - distach event: nodes', this.selectedEdges)
        this.dispatchEvent(selectedEdgesEvent);
      }

      _animatedEdgesChanged() {
        if (!this.graphView) {
          return;
        }
        this.graphView.setAnimatedEdges(this.animatedEdges);
      }

      // Graph changed event
      fireChanged(event) {
        this.log('Graph changed event', event)
        var changedEvent = new CustomEvent('changed', {
          bubbles: true
        })
        this.dispatchEvent(changedEvent);
      }

      _autolayoutChanged(layout, oldLayout) {
        console.log('autolayout changed', layout, oldLayout)
        if (!this.graph) {
          console.log('no graph to autolayout')
          return;
        }
        // Only listen to changes that affect layout
        if (this.autolayout) {
          this.log('Add graph on listeners for triggerAutolayout')
          var triggerAutolayout = this.triggerAutolayout.bind(this);

          this.graph.on('addNode', triggerAutolayout);
          this.graph.on('removeNode', triggerAutolayout);
          this.graph.on('addInport', triggerAutolayout);
          this.graph.on('removeInport', triggerAutolayout);
          this.graph.on('addOutport', triggerAutolayout);
          this.graph.on('removeOutport', triggerAutolayout);
          this.graph.on('addEdge', triggerAutolayout);
          this.graph.on('removeEdge', triggerAutolayout);
        } else {
          this.log('Remove graph on listeners for triggerAutolayout')
          this.graph.removeListener('addNode', this.triggerAutolayout);
          this.graph.removeListener('removeNode', this.triggerAutolayout);
          this.graph.removeListener('addInport', this.triggerAutolayout);
          this.graph.removeListener('removeInport', this.triggerAutolayout);
          this.graph.removeListener('addOutport', this.triggerAutolayout);
          this.graph.removeListener('removeOutport', this.triggerAutolayout);
          this.graph.removeListener('addEdge', this.triggerAutolayout);
          this.graph.removeListener('removeEdge', this.triggerAutolayout);
        }
      }

      triggerAutolayout(event) {
        var graph = this.graph;
        var portInfo = this.graphView ? this.graphView.portInfo : null;
        // Calls the autolayouter
        this.autolayouter.layout({
          "graph": graph,
          "portInfo": portInfo,
          "direction": "RIGHT",
          "options": {
            "intCoordinates": true,
            "algorithm": "de.cau.cs.kieler.klay.layered",
            "layoutHierarchy": true,
            "spacing": 36,
            "borderSpacing": 20,
            "edgeSpacingFactor": 0.2,
            "inLayerSpacingFactor": 2.0,
            "nodePlace": "BRANDES_KOEPF",
            "nodeLayering": "NETWORK_SIMPLEX",
            "edgeRouting": "POLYLINE",
            "crossMin": "LAYER_SWEEP",
            "direction": "RIGHT"
          }
        });
      }

      applyAutolayout(keilerGraph) {
        this.graph.startTransaction("autolayout");
        TheGraph.autolayout.applyToGraph(this.graph, keilerGraph, {
          snap: this.snap
        });
        this.graph.endTransaction("autolayout");

        // Fit to window
        this.triggerFit();

      }

      triggerFit() {
        if (this.appView) {
          this.appView.triggerFit();
        }
      }

      _widthChanged(width, oldWidth) {
        if (!this.appView) {
          return;
        }
        this.appView.setState({
          width: width
        });
      }

      _heightChanged(height, oldHeight) {
        if (!this.appView) {
          return;
        }
        this.appView.setState({
          height: height
        });
      }

      updateIcon(nodeId, icon) {
        if (!this.graphView) {
          return;
        }
        this.graphView.updateIcon(nodeId, icon);
      }

      rerender(options) {
        // This is throttled with rAF internally
        if (!this.graphView) {
          return;
        }
        this.graphView.markDirty(options);
      }

      addNode(id, component, metadata) {
        if (!this.graph) {
          return;
        }
        this.graph.addNode(id, component, metadata);
      }

      getPan() {
        if (!this.appView) {
          return [0, 0];
        }
        return [this.appView.state.x, this.appView.state.y];
      }

      _panChanged(pan, oldPan) {
        // Send pan back to React
        if (!this.appView) {
          return;
        }
        this.appView.setState({
          x: pan[0],
          y: pan[1]
        });
      }

      getScale() {
        if (!this.appView) {
          return 1;
        }
        return this.appView.state.scale;
      }

      _displaySelectionGroupChanged() {
        if (!this.graphView) {
          return;
        }
        this.graphView.setState({
          displaySelectionGroup: this.displaySelectionGroup
        });
      }

      forceSelectionChanged() {
        if (!this.graphView) {
          return;
        }
        this.graphView.setState({
          forceSelection: this.forceSelection
        });
      }

      focusNode(node) {
        this.appView.focusNode(node);
      }

      _menusChanged(menus, oldMenus) {
        // Only if the object itself changes,
        // otherwise builds menu from reference every time menu shown
        if (!this.appView) {
          return;
        }
        this.appView.setProps({
          menus: menus
        });
      }


      debounceLibraryRefesh() {
        // Breaking the "no debounce" rule, this fixes #76 for subgraphs
        if (this.debounceLibraryRefeshTimer) {
          clearTimeout(this.debounceLibraryRefeshTimer);
        }
        this.debounceLibraryRefeshTimer = setTimeout(function () {
          this.rerender({
            libraryDirty: true
          });
        }.bind(this), 200);
      }
      registerComponent(definition, generated) {
        var component = this.library[definition.name];
        var def = definition;
        if (component) {
          if (generated) {
            // Don't override real one with generated dummy
            return;
          }
          def = TheGraph.library.mergeComponentDefinition(component, definition);
        }
        this.library[definition.name] = def;
        // So changes are rendered
        this.debounceLibraryRefesh();
      }
      getComponent(name) {
        return this.library[name];
      }

      toJSON() {
        if (!this.graph) {
          return {};
        }
        return this.graph.toJSON();
      }
    }
    window.customElements.define(TheGraphElem.is, TheGraphElem);
  </script>
</dom-module>